# 消息中间件

- 

## 消息中间件之间区别

| -- | ActiveMQ | RabbitMQ | RocketMQ | Kafka | ZeroMQ |
| --- | --- | --- | --- | --- | --- | 
| 特点 | 功能齐全，被大量开源项目使用 | 由于Erlang 语言的并发能力，性能很好 | 各个环节分布式扩展设计，主从 HA；支持上万个队列；多种消费模式；性能很好 | Kafka的Producer、Broker和Consumer之间采用的是一套自行设计的基于TCP层的协议。Kafka的这套协议完全是为了Kafka自身的业务需求而定制的，而非要实现一套类似于Protocol Buffer的通用协议 | 低延时，高性能，最高 43万条消息每秒 |
| 开发语言 | Java | Erlang | Java | scala | C |
| 支持的协议 | OpenWire、STOMP、 REST、XMPP、 AMQP,MQTT | AMQP,STOMP，MQTT | 自己定义的一套(社区提供 JMS--不成熟) | PLAINTEXT、SSL、SASL_PLAINTEXT、SASL_SSL | TCP、UDP |
| 持久化 | 内存、文件、数据库 | 内存、文件 | 磁盘文件 | 内存，文件，数据库 | 在消息发送端保存 |
| 事务 | 支持 | 不支持 | 支持 | 支持 | 不支持 |
| 集群 | 支持 | 支持 | 支持 | 支持 | 不支持 |
| 负载均衡 | 支持 | 支持 | 支持 | 支持 | 不支持 |
| 管理界面 | 一般 | 好 | 无社区有 web; console 实现 | 好 | 无 |
| 部署方式 | 独立、嵌入 | 独立 | 独立 | 独立 | 独立 |
| 吞吐量 | 万级 | 万级 | 10万级 | 10万级 | 10万级 |
| 时效性 | ms级 | us级 | ms级 | ms级以内 | - |
| 评价 | 【优点】：成熟的产品，已经在很多公司得到应用（非大规模场景）。有较多的文档。各种协议支持较好，有多重语言的成熟的客户端；<br>【缺点】： 根据其他用户反馈，会出莫名其妙的问题，切会丢失消息。 其重心放到activemq6.0 产品—apollo 上去了，目前社区不活跃，且对 5.x 维护较少；<br> Activemq 不适合用于上千个队列的应用场景 | 【优点】：由于erlang语言的特性，mq 性能较好；管理界面较丰富，在互联网公司也有较大规模的应用；支持amqp系，多种语言且支持 amqp 的客户端可用；<br>【缺点】： erlang语言难度较大。集群不支持动态扩展 | 【优点】：模型简单，接口易用（JMS 的接口很多场合并不太实用）。在阿里大规模应用。目前支付宝中的余额宝等新兴产品均使用rocketmq。集群规模大概在50 台左右，单日处理消息上百亿；性能非常好，可以大量堆积消息在broker 中；支持多种消费，包括集群消费、广播消费等。开发度较活跃，版本更新很快；<br> 【缺点】：产品较新，文档比较缺乏。没有在 mq 核心中去实现JMS 等接口，对已有系统而言不能兼容。阿里内部还有一套未开源的 MQ API，这一层API可以将上层应用和下层 MQ 的实现解耦（阿里内部有多个mq的实现，如 notify、metaq1.x， metaq2.x，rocketmq 等），使得下面mq可以很方便的进行切换和升级而对应用无任何影响，目前这一套东西未开源 | 高吞吐量：Kafka 每秒可以生产约 25 万消息（50 MB），每秒处理 55 万消息（110 MB）<br>  持久化数据存储：可进行持久化操作。将消息持久化到磁盘，因此可用于批量消费，例如 ETL，以及实时应用程序。通过将数据持久化到硬盘以及replication 防止数据丢失。 <br> 分布式系统易于扩展：所有的 producer、broker 和 consumer 都会有多个，均为分布式的。无需停机即可扩展机器。 客户端状态维护：消息被处理的状态是在 consumer 端维护，而不是由 server 端维护。当失败时能自动平衡。 | 调用的socket接口较多。 TCP是一对一的连接。编程需要关注很多socket细节问题。不支持跨平台编程。需要自行处理分包、组包问题。流式传输时需处理粘包、半包问题。需自行处理网络异常，比如连接异常中断、重连等。 服务端和客户端启动有先后。 自行处理IO模型、自行实现消息的缓存、自行实现对消息的加密。 |
